<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Code Challenge · Cryptoeconomics.Study</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="&lt;!-- This file is generated by /website/scripts/sync-util.js - changes will be overwritten! --&gt;"/><meta name="docsearch:language" content="en"/><meta property="og:title" content="Code Challenge · Cryptoeconomics.Study"/><meta property="og:type" content="website"/><meta property="og:url" content="undefined/"/><meta property="og:description" content="&lt;!-- This file is generated by /website/scripts/sync-util.js - changes will be overwritten! --&gt;"/><meta name="twitter:card" content="summary"/><link rel="shortcut icon" href="/img/favicon.ico"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css"/><script>
              (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
              (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
              m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
              })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

              ga('create', 'UA-128367709-2', 'auto');
              ga('send', 'pageview');
            </script><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css"/><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><script src="https://unpkg.com/vanilla-back-to-top@7.1.14/dist/vanilla-back-to-top.min.js"></script><script>
        document.addEventListener('DOMContentLoaded', function() {
          addBackToTop(
            {"zIndex":100}
          )
        });
        </script><script src="/js/scrollSpy.js"></script><link rel="stylesheet" href="/css/prism.css"/><link rel="stylesheet" href="/css/main.css"/><script src="/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/en"><img class="logo" src="/img/ces-logo.png" alt="Cryptoeconomics.Study"/><h2 class="headerTitleWithLogo">Cryptoeconomics.Study</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class="siteNavGroupActive"><a href="/docs/en/sync/getting-started-welcome" target="_self">Course</a></li><li class=""><a href="/en/community" target="_self">Community</a></li><li class=""><a href="/docs/en/sync/dao-welcome" target="_self">Contribute</a></li><span><li><a id="languages-menu" href="#"><img class="languages-icon" src="/img/language.svg" alt="Languages icon"/>English</a><div id="languages-dropdown" class="hide"><ul id="languages-dropdown-items"><li><a href="/docs/zh-CN/sync/3.3-code-challenge">中文</a></li></ul></div></li><script>
        const languagesMenuItem = document.getElementById("languages-menu");
        const languagesDropDown = document.getElementById("languages-dropdown");
        languagesMenuItem.addEventListener("click", function(event) {
          event.preventDefault();

          if (languagesDropDown.className == "hide") {
            languagesDropDown.className = "visible";
          } else {
            languagesDropDown.className = "hide";
          }
        });
      </script></span></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><div class="hamburger-menu"><div class="line1"></div><div class="line2"></div><div class="line3"></div></div></div><h2><i>›</i><span>3.3 Merkle Trees</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">Getting Started<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/docs/en/sync/getting-started-welcome">Welcome</a></li><li class="navListItem"><a class="navItem" href="/docs/en/sync/getting-started-development-setup">Development Setup</a></li><li class="navListItem"><a class="navItem" href="/docs/en/sync/getting-started-course-overview">Course Overview</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">Ch1: Payment Processor<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><div class="navGroup subNavGroup"><h4 class="navGroupSubcategoryTitle">1.1 Hashes and Signatures</h4><ul><li class="navListItem"><a class="navItem" href="/docs/en/sync/1.1-lecture">Lecture</a></li><li class="navListItem"><a class="navItem" href="/docs/en/sync/1.1-code-challenge">Code Challenge</a></li></ul></div><div class="navGroup subNavGroup"><h4 class="navGroupSubcategoryTitle">1.2 Payment Processor</h4><ul><li class="navListItem"><a class="navItem" href="/docs/en/sync/1.2-lecture">Lecture</a></li><li class="navListItem"><a class="navItem" href="/docs/en/sync/1.2-code-challenge">Code Challenge</a></li></ul></div><div class="navGroup subNavGroup"><h4 class="navGroupSubcategoryTitle">1.3 Replay Protection</h4><ul><li class="navListItem"><a class="navItem" href="/docs/en/sync/1.3-lecture">Lecture</a></li><li class="navListItem"><a class="navItem" href="/docs/en/sync/1.3-code-challenge">Code Challenge</a></li></ul></div><div class="navGroup subNavGroup"><h4 class="navGroupSubcategoryTitle">1.4 Account Model vs UTXOs</h4><ul><li class="navListItem"><a class="navItem" href="/docs/en/sync/1.4-lecture">Lecture</a></li><li class="navListItem"><a class="navItem" href="/docs/en/sync/1.4-code-challenge">Code Challenge</a></li></ul></div><div class="navGroup subNavGroup"><h4 class="navGroupSubcategoryTitle">1.5 Centralized Systems</h4><ul><li class="navListItem"><a class="navItem" href="/docs/en/sync/1.5-lecture">Lecture</a></li><li class="navListItem"><a class="navItem" href="/docs/en/sync/1.5-code-challenge">Code Challenge</a></li></ul></div></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">Ch2: Network Models<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><div class="navGroup subNavGroup"><h4 class="navGroupSubcategoryTitle">2.1 Networks and Synchrony</h4><ul><li class="navListItem"><a class="navItem" href="/docs/en/sync/2.1-lecture">Lecture</a></li></ul></div><div class="navGroup subNavGroup"><h4 class="navGroupSubcategoryTitle">2.2 Double Spends</h4><ul><li class="navListItem"><a class="navItem" href="/docs/en/sync/2.2-lecture">Lecture</a></li><li class="navListItem"><a class="navItem" href="/docs/en/sync/2.2-code-challenge">Code Challenge</a></li></ul></div><div class="navGroup subNavGroup"><h4 class="navGroupSubcategoryTitle">2.3 Latency-Based Consensus</h4><ul><li class="navListItem"><a class="navItem" href="/docs/en/sync/2.3-lecture">Lecture</a></li><li class="navListItem"><a class="navItem" href="/docs/en/sync/2.3-code-challenge">Code Challenge</a></li></ul></div><div class="navGroup subNavGroup"><h4 class="navGroupSubcategoryTitle">2.4 Proof of Authority</h4><ul><li class="navListItem"><a class="navItem" href="/docs/en/sync/2.4-lecture">Lecture</a></li><li class="navListItem"><a class="navItem" href="/docs/en/sync/2.4-code-challenge">Code Challenge</a></li></ul></div></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">Ch3 Proof of Work<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><div class="navGroup subNavGroup"><h4 class="navGroupSubcategoryTitle">3.1 Decentralized Consensus and Blockchains</h4><ul><li class="navListItem"><a class="navItem" href="/docs/en/sync/3.1-lecture">Lecture</a></li></ul></div><div class="navGroup subNavGroup"><h4 class="navGroupSubcategoryTitle">3.2 Bitcoin and Nakamoto Consensus</h4><ul><li class="navListItem"><a class="navItem" href="/docs/en/sync/3.2-lecture">Lecture</a></li><li class="navListItem"><a class="navItem" href="/docs/en/sync/3.2-code-challenge">Code Challenge</a></li></ul></div><div class="navGroup subNavGroup"><h4 class="navGroupSubcategoryTitle">3.3 Merkle Trees</h4><ul><li class="navListItem"><a class="navItem" href="/docs/en/sync/3.3-lecture">Lecture</a></li><li class="navListItem navListItemActive"><a class="navItem" href="/docs/en/sync/3.3-code-challenge">Code Challenge</a></li></ul></div><div class="navGroup subNavGroup"><h4 class="navGroupSubcategoryTitle">3.4 Game Thoery in Bitcoin</h4><ul><li class="navListItem"><a class="navItem" href="/docs/en/sync/3.4-lecture">Lecture</a></li><li class="navListItem"><a class="navItem" href="/docs/en/sync/3.4-code-challenge">Code Challenge</a></li></ul></div><div class="navGroup subNavGroup"><h4 class="navGroupSubcategoryTitle">3.5 Selfish Mining</h4><ul><li class="navListItem"><a class="navItem" href="/docs/en/sync/3.5-lecture">Lecture</a></li><li class="navListItem"><a class="navItem" href="/docs/en/sync/3.5-code-challenge">Code Challenge</a></li></ul></div></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">More<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/docs/en/sync/more-resources">Resources</a></li><li class="navListItem"><a class="navItem" href="/docs/en/sync/more-glossary">Glossary</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              var headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                var el = event.target;
                while(el !== headings){
                  if (el.tagName === 'A') {
                    document.body.classList.remove('tocActive');
                    break;
                  } else{
                    el = el.parentNode;
                  }
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><a class="edit-page-link button" href="https://github.com/cryptoeconomics-study/code//blob/master/ch3/3.3/README.md" target="_blank" rel="noreferrer noopener">Edit</a><h1 class="postHeaderTitle">Code Challenge</h1></header><article><div><span><!-- This file is generated by /website/scripts/sync-util.js - changes will be overwritten! -->
<blockquote>
<p>Most of the code challenges in this course build upon each other. It's highly recommended that you start from the beginning. However, this challenge can be completed on its own! If you haven't already, get started with our <a href="https://www.burrrata.ch/ces-website/docs/en/sync/dev-env-setup">Installation Instructions</a>.</p>
</blockquote>
<blockquote>
<p>This lesson has been forked from <a href="https://www.chainshot.com/">Chainshot</a>. We highly recommend you check out their <a href="https://www.chainshot.com/explore">free coding lessons</a> and <a href="https://www.chainshot.com/classes">affordable online classes</a>!
<br /></p>
</blockquote>
<h1><a class="anchor" aria-hidden="true" id="merkle-trees"></a><a href="#merkle-trees" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Merkle Trees</h1>
<p>Merkle Trees are awesome! They allow us to verify one piece of data is part of a large data structure, without having all of its parts. This means they can be used to check for inconsistencies in all kinds of distributed systems!</p>
<p>For Blockchain, storing transactions as Merkle Trees allows us to look at a block and verify that a transaction was part of that block by only having part of the data set (average case <code>log(n)</code> where <code>n</code> is the number of leaf nodes).</p>
<p>Let's take a look at an example:</p>
<h3><a class="anchor" aria-hidden="true" id="abcdefghij-merkle-tree"></a><a href="#abcdefghij-merkle-tree" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>ABCDEFGHIJ Merkle Tree</h3>
<p>In this tree each letter represents a hash, and combining letters represents concatenating hashes and hashing those together.</p>
<pre><code class="hljs">          Root
        <span class="token operator">/</span>      \
    <span class="token constant">ABCD</span>        <span class="token constant">EFGHIJ</span>
     <span class="token operator">|</span>          <span class="token operator">/</span>    \
    <span class="token constant">ABCD</span>     <span class="token constant">EFGH</span>     <span class="token constant">IJ</span>
    <span class="token operator">/</span> \      <span class="token operator">/</span>   \     <span class="token operator">|</span>
   <span class="token constant">AB</span>  <span class="token constant">CD</span>   <span class="token constant">EF</span>   <span class="token constant">GH</span>   <span class="token constant">IJ</span>
  <span class="token operator">/</span> \  <span class="token operator">/</span> \  <span class="token operator">/</span> \  <span class="token operator">/</span> \  <span class="token operator">/</span> \
  <span class="token constant">A</span> <span class="token constant">B</span>  <span class="token constant">C</span> <span class="token constant">D</span>  <span class="token constant">E</span> <span class="token constant">F</span>  <span class="token constant">G</span> <span class="token constant">H</span>  <span class="token constant">I</span> <span class="token constant">J</span>
</code></pre>
<p>To prove that the hash <code>A</code> is a part of the Merkle Root we don't need to know Hash <code>C</code> or <code>D</code>, we just need to know Hash <code>CD</code>. The necessary proof for <code>A</code> is:</p>
<pre><code class="hljs"><span class="token function">Hash</span><span class="token punctuation">(</span><span class="token function">Hash</span><span class="token punctuation">(</span><span class="token function">Hash</span><span class="token punctuation">(</span><span class="token constant">A</span> <span class="token operator">+</span> <span class="token constant">B</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token constant">CD</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token constant">EFGHIJ</span><span class="token punctuation">)</span>
</code></pre>
<p>Where we only need to know the hashes <code>B</code>, <code>CD</code>, and <code>EFGHIJ</code> to prove that <code>A</code> is in the merkle root.</p>
<p>If you don't understand all of this, don't worry! That's what this lesson is for. You will understand soon and we'll come back to this over the coming stages.</p>
<h2><a class="anchor" aria-hidden="true" id="combine-two-leaves"></a><a href="#combine-two-leaves" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Combine Two Leaves</h2>
<p>Alright, let's build us a Merkle Tree!</p>
<p>The goal here is to take a bunch of &quot;leaves&quot; (the data hashes that make up the bottom layer of the tree) and hash them together two at a time to form a tree-like structure.</p>
<h3><a class="anchor" aria-hidden="true" id="add-a-constructor"></a><a href="#add-a-constructor" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Add a Constructor</h3>
<p>First things first, write a <strong>constructor</strong> for our MerkleTree class. This constructor will take two arguments:</p>
<ol>
<li>An array of leaf nodes for the Merkle Tree.</li>
<li>A <code>concat</code> function which can be used to concatenate two hashes together to form a new hash.</li>
</ol>
<p>Store both of these arguments on the Merkle Tree instance.</p>
<h3><a class="anchor" aria-hidden="true" id="constructor"></a><a href="#constructor" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Constructor</h3>
<p>A constructor is a specially named function in a <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes#Class_declarations">JavaScript Class</a> that will be called when an instance is created with <code>new</code>.</p>
<p>To add a constructor, simply use the <code>constructor</code> keyword as the name of the function within the class.</p>
<h3><a class="anchor" aria-hidden="true" id="let-s-get-to-the-root"></a><a href="#let-s-get-to-the-root" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Let's get to the Root</h3>
<p>Now we need to add a function <code>getRoot</code> to our class that allows us to find the merkle root.</p>
<p>For this stage the only test case setup is taking two roots and hashing them together. Our tree will look like this:</p>
<pre><code class="hljs">    Root
    <span class="token operator">/</span>  \
   <span class="token constant">A</span>    <span class="token constant">B</span>
</code></pre>
<p>Where <code>A</code> and <code>B</code> are our leaf hashes and the root is the combined hash.</p>
<p>We'll simply need to take our two leaf hashes and combine them using the <code>concat</code> function passed into the MerkleTree constructor. This function expects two arguments, the left and right leaf node.</p>
<p>On the next stage we'll move onto some more in-depth scenarios.</p>
<h3><a class="anchor" aria-hidden="true" id="concat-function"></a><a href="#concat-function" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Concat Function</h3>
<p>To simplify this merkle tree implementation and to make debugging easier, we'll pass a concatenation function from the tests into the MerkleTree constructor.</p>
<p>This is the function that combines two leaf nodes and hashes them together. For instance in a four-leaf tree:</p>
<pre><code class="hljs">    Root
    <span class="token operator">/</span> \
   <span class="token constant">AB</span>  <span class="token constant">CD</span>
  <span class="token operator">/</span> \  <span class="token operator">/</span> \
  <span class="token constant">A</span> <span class="token constant">B</span>  <span class="token constant">C</span> <span class="token constant">D</span>
</code></pre>
<p>This function is used three times, for each combination. I'll write it here as <code>Hash</code>:</p>
<p><code>Hash(Hash(A + B) + Hash(C + D))</code></p>
<blockquote>
<p>If you deep dive into the test cases you'll notice that we can even use the concatenation function to determine the hashing path you used (in the format shown above) to help with debugging in the next few steps.</p>
</blockquote>
<h2><a class="anchor" aria-hidden="true" id="multiple-layers"></a><a href="#multiple-layers" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Multiple Layers</h2>
<p>Awesome! Now it's time to create a larger Merkle Tree.</p>
<h3><a class="anchor" aria-hidden="true" id="four-leaf-tree"></a><a href="#four-leaf-tree" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Four Leaf Tree</h3>
<p>Now we need to make sure to handle a case where there are multiple layers of hashing. First we hash together <code>A</code> and <code>B</code>, then we hash together <code>C</code> and <code>D</code>. Then we hash together the combination of <code>A</code> and <code>B</code> (<code>AB</code>) with the combination of <code>C</code> and <code>D</code> (<code>CD</code>). Something like this:</p>
<pre><code class="hljs">    Root
    <span class="token operator">/</span>  \
   <span class="token constant">AB</span>  <span class="token constant">CD</span>
  <span class="token operator">/</span> \  <span class="token operator">/</span> \
  <span class="token constant">A</span> <span class="token constant">B</span>  <span class="token constant">C</span> <span class="token constant">D</span>
</code></pre>
<p>To do this is may be useful to think of the tree as having multiple layers, where the first layer is the leaves (<code>A</code>, <code>B</code>, <code>C</code>, <code>D</code>) the second is the combination of both of those branches (<code>AB</code>, <code>CD</code>) and then we reach our Merkle Root or the combination of all branches (<code>ABCD</code>).</p>
<p>It may be helpful to rememberwhat we're trying to accomplish by hashing at multiple layers.</p>
<p>This is a tough algorithm to work through.</p>
<h2><a class="anchor" aria-hidden="true" id="the-goal"></a><a href="#the-goal" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>The Goal</h2>
<p><strong>What's the goal of writing a tree structure of hash combinations?</strong></p>
<p>Consider the four leaf example:</p>
<pre><code class="hljs">    Root
    <span class="token operator">/</span>  \
   <span class="token constant">AB</span>  <span class="token constant">CD</span>
  <span class="token operator">/</span> \  <span class="token operator">/</span> \
  <span class="token constant">A</span> <span class="token constant">B</span>  <span class="token constant">C</span> <span class="token constant">D</span>
</code></pre>
<p>Because <code>CD</code> is a combination of <code>C</code> and <code>D</code> and the <code>Root</code> is a combination of <code>AB</code> and <code>CD</code>, we can see that the hash <code>C</code> will directly affect the resulting hash in the <code>Root</code>. From <code>C</code>'s perspective all we need to know is <code>D</code> and <code>AB</code> to create the <code>Root</code>:</p>
<pre><code class="hljs"><span class="token function">Hash</span><span class="token punctuation">(</span><span class="token constant">AB</span><span class="token punctuation">,</span> <span class="token function">Hash</span><span class="token punctuation">(</span><span class="token constant">C</span><span class="token punctuation">,</span> <span class="token constant">D</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> Root
</code></pre>
<p>Notice that, in this equation, we can completely forget about <code>A</code> and <code>B</code>. We don't need to know what they are to prove that <code>C</code> is in the <code>Root</code>. We just need the hashes <code>D</code> and <code>AB</code>.</p>
<p>This optimization is the power of Merkle Trees and it becomes even more apparent with larger trees where less data is necessary to prove that a leaf node is part of the tree.</p>
<h2><a class="anchor" aria-hidden="true" id="recommended-approach"></a><a href="#recommended-approach" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Recommended Approach</h2>
<p>There's a few ways to attempt writing this algorithm. The most elegant solutions are likely recursive. This doesn't necessarily mean that you can't attempt it iteratively! Either way, let's break down the thought process on how to approach this.</p>
<p>We have a merkle tree with some arbitrary number of leaf nodes. Maybe it's the four leaf tree:</p>
<pre><code class="hljs">    Root
    <span class="token operator">/</span>  \
   <span class="token constant">AB</span>  <span class="token constant">CD</span>
  <span class="token operator">/</span> \  <span class="token operator">/</span> \
  <span class="token constant">A</span> <span class="token constant">B</span>  <span class="token constant">C</span> <span class="token constant">D</span>
</code></pre>
<p>Maybe it's the eight leaf tree:</p>
<pre><code class="hljs">        Root
       <span class="token operator">/</span>    \
    <span class="token constant">ABCD</span>     <span class="token constant">EFGH</span>
    <span class="token operator">/</span> \      <span class="token operator">/</span> \
   <span class="token constant">AB</span>  <span class="token constant">CD</span>   <span class="token constant">EF</span>  <span class="token constant">GH</span>
  <span class="token operator">/</span> \  <span class="token operator">/</span> \  <span class="token operator">/</span> \ <span class="token operator">/</span> \
  <span class="token constant">A</span> <span class="token constant">B</span>  <span class="token constant">C</span> <span class="token constant">D</span>  <span class="token constant">E</span> <span class="token constant">F</span> <span class="token constant">G</span> <span class="token constant">H</span>
</code></pre>
<p>Our recommended approach to this problem, is to break it down into layers. For each layer, we want to go through every 2 nodes and concatenate them.</p>
<p>So, if we're on the bottom layer, we want to take <code>A</code> and <code>B</code> and concatenate them to make <code>AB</code>, <code>C</code> and <code>D</code> to make <code>CD</code> and so on until we have four nodes <code>AB</code>, <code>CD</code>, <code>EF</code>, <code>GH</code>.</p>
<p>Once we've done that, we'll move up to the next layer and do the same. Concatenate <code>AB</code> and <code>CD</code> to get <code>ABCD</code>. Concatenate <code>EF</code> and <code>GH</code> to make <code>EFGH</code>.</p>
<p>We'll repeat this one more time, for the last layer to get our merkle root <code>ABCDEFGH</code>.</p>
<p>We could preemptively calculate how many layers we need to reduce, or we could keep an array of nodes and when it's <code>length</code> is one we know we've reached the merkle root.</p>
<p>It's up to you how to solve it. Make sure you consider the algorithm for each layer as well as your exit condition carefully!</p>
<h2><a class="anchor" aria-hidden="true" id="odd-leaves"></a><a href="#odd-leaves" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Odd Leaves</h2>
<p>Great! Now we can build large merkle trees. But, can we build them with an odd number of leaves?</p>
<h3><a class="anchor" aria-hidden="true" id="three-leaf-tree"></a><a href="#three-leaf-tree" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Three Leaf Tree</h3>
<p>Now let's consider what happens in the case of an odd number of leaves in a tree. Any time that there is no right side of the particular branch, we're just going to want to carry the hash one layer up:</p>
<pre><code class="hljs">    Root
    <span class="token operator">/</span> \
   <span class="token constant">AB</span>  <span class="token constant">C</span>
  <span class="token operator">/</span> \  <span class="token operator">|</span>
  <span class="token constant">A</span> <span class="token constant">B</span>  <span class="token constant">C</span>
</code></pre>
<p>In this case we don't use the <code>C</code> hash until we hash it together with <code>AB</code> to create the Merkle Root. Let's handle this in our test cases.</p>
<h2><a class="anchor" aria-hidden="true" id="other-odd-trees"></a><a href="#other-odd-trees" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Other Odd Trees</h2>
<p>The rule for odd trees is always to use up everything towards the left side before filling out the right side of the tree.</p>
<h3><a class="anchor" aria-hidden="true" id="five-leaf-tree"></a><a href="#five-leaf-tree" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Five Leaf Tree</h3>
<p>With five leaves, we use the first four as the left side and bring the fifth hash all the way up until the last combination.</p>
<pre><code class="hljs">      Root
     <span class="token operator">/</span>    \
    <span class="token constant">ABCD</span>   <span class="token constant">E</span>
    <span class="token operator">/</span> \    <span class="token operator">|</span>
   <span class="token constant">AB</span>  <span class="token constant">CD</span>  <span class="token constant">E</span>
  <span class="token operator">/</span> \  <span class="token operator">/</span> \ <span class="token operator">|</span>
  <span class="token constant">A</span> <span class="token constant">B</span>  <span class="token constant">C</span> <span class="token constant">D</span> <span class="token constant">E</span>
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="seven-leaf-tree"></a><a href="#seven-leaf-tree" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Seven Leaf Tree</h3>
<p>With seven leaves, the last three hashes work similar to a three leaf tree to build up the <code>EFG</code>  combination and then combines with the first four hashes.</p>
<pre><code class="hljs">        Root
       <span class="token operator">/</span>    \
    <span class="token constant">ABCD</span>     <span class="token constant">EFG</span>
    <span class="token operator">/</span> \      <span class="token operator">/</span> \
   <span class="token constant">AB</span>  <span class="token constant">CD</span>   <span class="token constant">EF</span>  <span class="token constant">G</span>
  <span class="token operator">/</span> \  <span class="token operator">/</span> \  <span class="token operator">/</span> \ <span class="token operator">|</span>
  <span class="token constant">A</span> <span class="token constant">B</span>  <span class="token constant">C</span> <span class="token constant">D</span>  <span class="token constant">E</span> <span class="token constant">F</span> <span class="token constant">G</span>
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="build-the-proof"></a><a href="#build-the-proof" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Build The Proof</h2>
<p>Alright, now it's time to build the proof that a particular leaf node exists within a merkle tree!</p>
<p>With this proof, we'll only want to include the necessary hashes we need to create the root hash from our target leaf node.</p>
<h2><a class="anchor" aria-hidden="true" id="add-the-getproof-method"></a><a href="#add-the-getproof-method" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Add the getProof Method</h2>
<p>Let's add a <code>getProof</code> method to our Merkle Tree, this function will take in an index of a leaf node and give us back a merkle proof, which is the minimum necessary hashes we'll need to prove the leaf node belongs in the tree.</p>
<h3><a class="anchor" aria-hidden="true" id="recommended-approach-1"></a><a href="#recommended-approach-1" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Recommended Approach</h3>
<p>This is a difficult algorithm to come up with, so we've included a recommended approach.</p>
<p>You'll want to approach this similar to how you did the <code>getRoot</code> algorithm. If you think of the algorithm in terms of layers, we can figure out what need to do on each layer.</p>
<p>Let's use the ABCDE Merkle Tree for an example:</p>
<pre><code class="hljs">      Root
     <span class="token operator">/</span>   \
   <span class="token constant">ABCD</span>   <span class="token constant">E</span>
   <span class="token operator">/</span> \    <span class="token operator">|</span>
  <span class="token constant">AB</span>  <span class="token constant">CD</span>  <span class="token constant">E</span>
 <span class="token operator">/</span> \  <span class="token operator">/</span> \ <span class="token operator">|</span>
 <span class="token constant">A</span> <span class="token constant">B</span>  <span class="token constant">C</span> <span class="token constant">D</span> <span class="token constant">E</span>
</code></pre>
<p>Let's say we want to prove C exists in the tree. We're given the index 2, which corresponds to the C's position in the array passed into our Merkle Tree constructor.</p>
<p>So we start at <code>C</code> on the bottom layer. What do we need to first?</p>
<p>We need to know if <code>C</code> is the left or right node in its pairing. We can determine this by checking <code>C</code>'s index (2). Two is even so it is a left node. Now that we know that, we need to add one to our index to get the right node: <code>D</code>. We add <code>D</code> to our proof and say it is <code>left: false</code> (because it's on the right).</p>
<p>Our proof so far: <code>[{ data: 'D', left: false }]</code></p>
<p>Next we need to move up a layer. Since we started at <code>C</code> and we have <code>D</code> in our proof, we have what we need to make hash <code>CD</code>. That means we want to go from our current index 2, to index 1. Since our merkle tree is a binary tree, each layer concatenates its pairs to result in half the number of leaf nodes (with the exception of the odd node). This means we can divide our current index by 2 and take the floor of it. (<code>Math.floor(2/2)</code> which is 1).</p>
<p>So now we move to index 1 on the second layer, which is <code>CD</code>. We need to again check if <code>CD</code> is a left or right node. Since it's an odd number, it's a right node. We'll subtract one to get it's left node <code>AB</code> and add it to our proof:</p>
<p>Our proof so far: <code>[{ data: 'D', left: false }, { data: 'AB', left: true }]</code></p>
<p>If we repeat this pattern, we'll divide our index (1) by 2, take the floor (0) and be at <code>ABCD</code>. We'll grab the right node <code>E</code> and add that to our proof:</p>
<pre><code class="hljs"><span class="token punctuation">[</span>
 <span class="token punctuation">{</span> data<span class="token punctuation">:</span> <span class="token string">'D'</span><span class="token punctuation">,</span> left<span class="token punctuation">:</span> <span class="token boolean">false</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
 <span class="token punctuation">{</span> data<span class="token punctuation">:</span> <span class="token string">'AB'</span><span class="token punctuation">,</span> left<span class="token punctuation">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
 <span class="token punctuation">{</span> data<span class="token punctuation">:</span> <span class="token string">'E'</span><span class="token punctuation">,</span> left<span class="token punctuation">:</span> <span class="token boolean">false</span> <span class="token punctuation">}</span>
<span class="token punctuation">]</span>
</code></pre>
<p>And we're done!</p>
<h3><a class="anchor" aria-hidden="true" id="abcde-merkle-tree-example"></a><a href="#abcde-merkle-tree-example" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>ABCDE Merkle Tree Example</h3>
<pre><code class="hljs">      Root
     <span class="token operator">/</span>    \
    <span class="token constant">ABCD</span>   <span class="token constant">E</span>
    <span class="token operator">/</span> \    <span class="token operator">|</span>
   <span class="token constant">AB</span>  <span class="token constant">CD</span>  <span class="token constant">E</span>
  <span class="token operator">/</span> \  <span class="token operator">/</span> \ <span class="token operator">|</span>
  <span class="token constant">A</span> <span class="token constant">B</span>  <span class="token constant">C</span> <span class="token constant">D</span> <span class="token constant">E</span>
</code></pre>
<p><strong>Proof of C</strong></p>
<p>To Prove <code>C</code> can build the Merkle Root, we can look at the path we need to take to hash up to the root:</p>
<pre><code class="hljs"><span class="token function">Hash</span><span class="token punctuation">(</span><span class="token function">Hash</span><span class="token punctuation">(</span><span class="token constant">AB</span> <span class="token operator">+</span> <span class="token function">Hash</span><span class="token punctuation">(</span><span class="token constant">C</span> <span class="token operator">+</span> <span class="token constant">D</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token constant">E</span><span class="token punctuation">)</span>
</code></pre>
<p>So the four hashes in use here are <code>AB</code>, <code>C</code>, <code>D</code>, and <code>E</code>. Since we're starting with <code>C</code>, we don't need that node in the proof. We'll need to know the hashes <code>AB</code>, <code>D</code> and <code>E</code>.</p>
<p>Also (and this is important!) we need to know the order in which they should be hashed. <code>Hash(A + B)</code> will not be the same as <code>Hash(B + A)</code>. Our proof should contain the <code>data</code> (the hash) and whether or not the node is in the <code>left</code> position.</p>
<p>Our resulting proof would look like this:</p>
<pre><code class="hljs"><span class="token punctuation">[</span>
 <span class="token punctuation">{</span> data<span class="token punctuation">:</span> <span class="token string">'D'</span><span class="token punctuation">,</span> left<span class="token punctuation">:</span> <span class="token boolean">false</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
 <span class="token punctuation">{</span> data<span class="token punctuation">:</span> <span class="token string">'AB'</span><span class="token punctuation">,</span> left<span class="token punctuation">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
 <span class="token punctuation">{</span> data<span class="token punctuation">:</span> <span class="token string">'E'</span><span class="token punctuation">,</span> left<span class="token punctuation">:</span> <span class="token boolean">false</span> <span class="token punctuation">}</span>
<span class="token punctuation">]</span>
</code></pre>
<p>By looking at that proof, we can easily concatenate to the root. We start with <code>C</code>, concatenate <code>D</code> on the right (<code>CD</code>), concatenate <code>AB</code> to the left (<code>ABCD</code>) and then concatenate <code>E</code> on the right to get the root <code>ABCDE</code>.</p>
<p>Look at that! We didn't even need to know <code>A</code> or <code>B</code>, just the combined hash of the two.</p>
<h2><a class="anchor" aria-hidden="true" id="another-example"></a><a href="#another-example" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Another Example</h2>
<p>Let's prove A belongs in the ABCDEFGHIJ Merkle Tree</p>
<pre><code class="hljs">                Root
              <span class="token operator">/</span>      \
      <span class="token constant">ABCDEFGH</span>        <span class="token constant">IJ</span>
      <span class="token operator">/</span>      \         <span class="token operator">|</span>
    <span class="token constant">ABCD</span>     <span class="token constant">EFGH</span>     <span class="token constant">IJ</span>
    <span class="token operator">/</span> \      <span class="token operator">/</span>   \     <span class="token operator">|</span>
   <span class="token constant">AB</span>  <span class="token constant">CD</span>   <span class="token constant">EF</span>   <span class="token constant">GH</span>   <span class="token constant">IJ</span>
  <span class="token operator">/</span> \  <span class="token operator">/</span> \  <span class="token operator">/</span> \  <span class="token operator">/</span> \  <span class="token operator">/</span> \
  <span class="token constant">A</span> <span class="token constant">B</span>  <span class="token constant">C</span> <span class="token constant">D</span>  <span class="token constant">E</span> <span class="token constant">F</span>  <span class="token constant">G</span> <span class="token constant">H</span>  <span class="token constant">I</span> <span class="token constant">J</span>
</code></pre>
<p>In order to prove A is in this tree we'll need the following proof path:</p>
<pre><code class="hljs"><span class="token function">Hash</span><span class="token punctuation">(</span><span class="token function">Hash</span><span class="token punctuation">(</span><span class="token function">Hash</span><span class="token punctuation">(</span><span class="token function">Hash</span><span class="token punctuation">(</span><span class="token constant">A</span> <span class="token operator">+</span> <span class="token constant">B</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token constant">CD</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token constant">EFGH</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token constant">IJ</span><span class="token punctuation">)</span>
</code></pre>
<p>So we'll need four hashes: <code>B</code>, <code>CD</code>, <code>EFGH</code>, and <code>IJ</code>.</p>
<pre><code class="hljs"><span class="token punctuation">[</span>
 <span class="token punctuation">{</span> data<span class="token punctuation">:</span> <span class="token string">'B'</span><span class="token punctuation">,</span> left<span class="token punctuation">:</span> <span class="token boolean">false</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
 <span class="token punctuation">{</span> data<span class="token punctuation">:</span> <span class="token string">'CD'</span><span class="token punctuation">,</span> left<span class="token punctuation">:</span> <span class="token boolean">false</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
 <span class="token punctuation">{</span> data<span class="token punctuation">:</span> <span class="token string">'EFGH'</span><span class="token punctuation">,</span> left<span class="token punctuation">:</span> <span class="token boolean">false</span> <span class="token punctuation">}</span>
 <span class="token punctuation">{</span> data<span class="token punctuation">:</span> <span class="token string">'IJ'</span><span class="token punctuation">,</span> left<span class="token punctuation">:</span> <span class="token boolean">false</span> <span class="token punctuation">}</span>
<span class="token punctuation">]</span>
</code></pre>
<p>Such a big tree and we only need four hashes to prove <code>A</code>! For <code>I</code> or <code>J</code> the savings would be even better in this tree, only two hashes necessary for their proofs. Very cool!</p>
<h2><a class="anchor" aria-hidden="true" id="example-proof"></a><a href="#example-proof" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Example Proof</h2>
<p>In the previous section we used the <code>ABCDE</code> merkle tree and created a proof of <code>C</code> being in the tree.</p>
<h3><a class="anchor" aria-hidden="true" id="abcde-merkle-tree"></a><a href="#abcde-merkle-tree" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>ABCDE Merkle Tree</h3>
<pre><code class="hljs">      Root
     <span class="token operator">/</span>    \
    <span class="token constant">ABCD</span>   <span class="token constant">E</span>
    <span class="token operator">/</span> \    <span class="token operator">|</span>
   <span class="token constant">AB</span>  <span class="token constant">CD</span>  <span class="token constant">E</span>
  <span class="token operator">/</span> \  <span class="token operator">/</span> \ <span class="token operator">|</span>
  <span class="token constant">A</span> <span class="token constant">B</span>  <span class="token constant">C</span> <span class="token constant">D</span> <span class="token constant">E</span>
</code></pre>
<p><strong>Proof of C</strong></p>
<p>As we said in the previous stage, the hash path is as follows:</p>
<pre><code class="hljs"><span class="token function">Hash</span><span class="token punctuation">(</span><span class="token function">Hash</span><span class="token punctuation">(</span><span class="token constant">AB</span> <span class="token operator">+</span> <span class="token function">Hash</span><span class="token punctuation">(</span><span class="token constant">C</span> <span class="token operator">+</span> <span class="token constant">D</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token constant">E</span><span class="token punctuation">)</span>
</code></pre>
<p>In order to verify this proof then we need to take three steps:</p>
<ol>
<li>Hash <code>C</code> and <code>D</code></li>
<li>Hash the result together with <code>AB</code> (prepend it)</li>
<li>Hash the result together with <code>E</code> (append it)</li>
</ol>
<p>After this is complete, our resulting hash is our merkle root: <code>ABCDE</code>.</p>
<h2><a class="anchor" aria-hidden="true" id="verifying-your-proof"></a><a href="#verifying-your-proof" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Verifying your Proof</h2>
<p>Almost done! Remember that proof that we just made in the last stage? It's time to verify it. The test cases will include some valid proofs and some invalid proofs, your algorithm will need to know the difference.</p>
<p><strong>The <code>verifyProof</code> Function</strong></p>
<p>In your <code>verify.js</code> file there is a the stub of <code>verifyProof</code> function. This function will take four parameters: <code>proof</code>, <code>node</code>, <code>root</code> and <code>concat</code>. Here are their definitions:</p>
<ol>
<li><code>proof</code> - The proof we created in the previous stage. It's an array of objects containing the <code>data</code> and whether or not the node is in the <code>left</code> position.</li>
<li><code>node</code> - The node we're trying to prove is within the merkle tree. If, along with the proof data, it can be concatenated to form the merkle root then the proof is valid!</li>
<li><code>root</code> - A <strong>buffer</strong> that is the resulting merkle root from the concatenation of all the leaf nodes in the merkle tree.</li>
</ol>
<blockquote>
<p>The <a href="https://nodejs.org/api/buffer.html#buffer_class_buffer">Node JS Buffer Class</a> allows us to easily interact with binary data. To compare buffers we can use the <code>.equals()</code> <a href="https://nodejs.org/api/buffer.html#buffer_buf_equals_otherbuffer">method</a>.</p>
</blockquote>
<ol start="4">
<li><code>concat</code> - The method used to concatenate the leaf nodes. The returned value is a <strong>buffer</strong>.</li>
</ol>
<p>Once you have concatenated all the nodes together, you can compare it to the <code>root</code> node with the <code>.equals()</code> <a href="https://nodejs.org/api/buffer.html#buffer_buf_equals_otherbuffer">method</a>.</p>
<blockquote>
<p>As always, if you have questions or get stuck please hit up the community on the <a href="https://forum.cryptoeconomics.study">forum!</a></p>
</blockquote>
</span></div></article></div><div class="docLastUpdate"><em>Last updated on 9/6/2019 by burrrata</em></div><div class="docs-prevnext"><a class="docs-prev button" href="/docs/en/sync/3.3-lecture"><span class="arrow-prev">← </span><span>Lecture</span></a><a class="docs-next button" href="/docs/en/sync/3.4-lecture"><span>Lecture</span><span class="arrow-next"> →</span></a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#combine-two-leaves">Combine Two Leaves</a><ul class="toc-headings"><li><a href="#add-a-constructor">Add a Constructor</a></li><li><a href="#constructor">Constructor</a></li><li><a href="#let-s-get-to-the-root">Let's get to the Root</a></li><li><a href="#concat-function">Concat Function</a></li></ul></li><li><a href="#multiple-layers">Multiple Layers</a><ul class="toc-headings"><li><a href="#four-leaf-tree">Four Leaf Tree</a></li></ul></li><li><a href="#the-goal">The Goal</a></li><li><a href="#recommended-approach">Recommended Approach</a></li><li><a href="#odd-leaves">Odd Leaves</a><ul class="toc-headings"><li><a href="#three-leaf-tree">Three Leaf Tree</a></li></ul></li><li><a href="#other-odd-trees">Other Odd Trees</a><ul class="toc-headings"><li><a href="#five-leaf-tree">Five Leaf Tree</a></li><li><a href="#seven-leaf-tree">Seven Leaf Tree</a></li></ul></li><li><a href="#build-the-proof">Build The Proof</a></li><li><a href="#add-the-getproof-method">Add the getProof Method</a><ul class="toc-headings"><li><a href="#recommended-approach-1">Recommended Approach</a></li><li><a href="#abcde-merkle-tree-example">ABCDE Merkle Tree Example</a></li></ul></li><li><a href="#another-example">Another Example</a></li><li><a href="#example-proof">Example Proof</a><ul class="toc-headings"><li><a href="#abcde-merkle-tree">ABCDE Merkle Tree</a></li></ul></li><li><a href="#verifying-your-proof">Verifying your Proof</a></li></ul></nav></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/" class="nav-home"></a><div><h5>Course</h5><a href="/docs/en/getting-started/welcome">Getting Started</a><a href="/en/coding-challenges">Coding Challenges</a></div><div><h5>Community</h5><a href="https://rinkeby.aragon.org/#/0xEAA147020b006e6Bfe9e3e1A9f1FaD330A9E20F5/">DAO</a><a href="https://forum.cryptoeconomics.study/">Forum</a><a href="/en/users.html">Contributors</a></div><div><h5>More</h5><a href="/blog">Blog</a><a href="https://cryptoeconomicsstudy.substack.com/subscribe">Newsletter</a><a href="https://github.com/cryptoeconomics-study-dao/">GitHub</a></div></section><section class="copyright">Copyright © 2019 Cryptoeconomics.Study</section></footer></div></body></html>